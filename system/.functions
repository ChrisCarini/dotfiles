##
#  Additional Bash Functions
##

# Add to end of path
append_path() {
    # Trim any whitespace from the input - xargs is easy trick for this (ref: https://stackoverflow.com/a/12973694 )
    NEW_PATH=$(/bin/echo $1 | /usr/bin/xargs )

    # Remove any newlines from path before appending the new path. This seems to happen from time-to-time after exporting.
    [ -d $NEW_PATH ] && PATH="$(/bin/echo $PATH | /usr/bin/tr -d '\n'):$NEW_PATH"
}
# Add to beginning of path
prepend_path() {
  [ -d $1 ] && PATH="$1:$PATH"
}

##
# Git / SCM Related
##
git-config-repo-github() {
	git config user.name "ChrisCarini"
	git config user.email "6374067+ChrisCarini@users.noreply.github.com"
	git config commit.gpgsign true
	git config user.signingkey EE9A157DBD0CFCB7
#	git config -l | cat
}

git-sync-fork() {
  # Assumes you've locally added an `upstream` remote to your fork; eg below:
  #
  #   git remote add upstream git@github.com:JetBrains/intellij-community.git
  git fetch upstream
  git checkout $(git remote show origin | grep 'HEAD branch:' | awk '{print $4}')
  git merge upstream/$(git remote show upstream | grep 'HEAD branch:' | awk '{print $4}')
}

# From https://stackoverflow.com/a/60303161/21599954
git-full-clone-to-shallow() {
  ORIGIN_URL=$(git remote get-url origin)
  COMMIT=$(git rev-parse HEAD)

  rm -rf .git
  git init .
  git remote add origin $ORIGIN_URL
  git fetch origin $COMMIT --depth 1
  git reset --mixed $COMMIT
}

mark_pr_ready_and_auto_merge_on_checks_complete() {
  PR="$1"

  RESULT_CODE="0"
  
  REQ_CHECKS_PASSED_COUNT=3
  CHECKS_PASSED_COUNT=$REQ_CHECKS_PASSED_COUNT
  while true; do
    RESULTS=$(gh pr view --json statusCheckRollup "$PR" --template '{{range .statusCheckRollup}}{{$x := ""}}{{if eq .conclusion "SUCCESS"}}{{$x = "✓"}}{{else if eq .conclusion "NEUTRAL"}}{{$x = "-"}}{{else}}{{$x = "*"}}{{end}}{{tablerow $x .name .status .conclusion "\033[0K"}}{{end}}{{tablerender}}')
    LENGTH=$(echo "$RESULTS" | wc -l)
    STATUS=$(echo "$RESULTS" | \grep -v "Owner Approval" | \grep -v "Code Ownership" | \grep -v "SUCCESS" | \grep -v "NEUTRAL" | \grep -Ev "COMPLETED \s* SKIPPED" | \grep -Ev "SonarQube Code Analysis \s* COMPLETED \s* FAILURE") # We don't want the results itself, just the status code
    RESULT_CODE=$?
    echo "$RESULTS"
    # If this status check passed, decrement the checks passed count; otherwise reset to 3
    if [[ -z "$STATUS" ]]; then
      CHECKS_PASSED_COUNT=$((CHECKS_PASSED_COUNT - 1))
      echo "[$(date +"%Y-%m-%d %H:%M:%S")] Checks passed $((REQ_CHECKS_PASSED_COUNT - CHECKS_PASSED_COUNT)) times..."
      LENGTH=$((LENGTH + 1))
    else 
      CHECKS_PASSED_COUNT=$REQ_CHECKS_PASSED_COUNT
    fi
    
    # If all checks have passed 3 times in a row, break out of the loop
    if [[ "$CHECKS_PASSED_COUNT" -eq 0 ]]; then
      break
    fi
    echo "                                                                       " # lots of spaces to clear the line
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] Waiting for checks to pass on PR #$PR..."
    sleep 5
    tput cuu "$((LENGTH + 2))" # move the cursor up N+1 lines to overwrite the previous output
  done

  echo "All checks passed (confirmed $REQ_CHECKS_PASSED_COUNT times)!"

  echo "Marking PR Ready For Review & enabling Auto-Merge"
  gh pr ready "$PR"
  gh pr merge --auto --squash "$PR"
}

is_pr_published() {
  PR="$1"

  RESULT_CODE="0"
  
  while true; do
    RESULTS=$(gh pr view --json comments "$PR" | jq '.comments | max_by(.createdAt) | {author: .author.login, body: .body}' | jq -r .body | \grep -E "(Published version\:|published version) (.*)")
    RESULT_CODE=$?
    
    # if RESULT_CODE is 0, then the PR has been published
    if [[ "$RESULT_CODE" -eq 0 ]]; then
      echo "[$(date +"%Y-%m-%d %H:%M:%S")] PR #$PR has been published!"
      echo "[$(date +"%Y-%m-%d %H:%M:%S")] ${RESULTS}                            " # extra space to clear prev line
      break
    fi
    
    echo "                                                                       " # lots of spaces to clear the line
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] Waiting for PR #$PR to be published..."
    sleep 5
    tput cuu 2 # move the cursor up 2 lines to overwrite the previous output
  done
}

is_pr_merged() {
  PR_NUM=$1
  echo "[$(date +"%Y-%m-%d %H:%M:%S")] Checking if PR #${PR_NUM} is merged..."
  until [[ "$(gh pr view "${PR_NUM}" --json state --jq .state)" == "MERGED" ]]; do
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] Waiting for PR #${PR_NUM} to be merged..."
    sleep 5
    tput cuu 1 # move the cursor up 1 line to overwrite the previous output
  done
  echo "[$(date +"%Y-%m-%d %H:%M:%S")] PR #${PR_NUM} is merged!                         " # extra space to clear prev line
}

# TODO(ChrisCarini) - Turn this into a `gh extension` command. See `GitJournal/Projects/PROJECT_IDEAS.md` for more info.
ship() {
  URL=$1
  echo -n "[$(date +"%Y-%m-%d %H:%M:%S")] Approving PR: ${URL}..."
  gh pr review --approve $URL
  echo "Done."
}

##
# Misc
##

# See `.functions.macos` for MacOS specific (shows notification)
dingdingding() {
    tput bel;sleep 0.5;
    tput bel;sleep 0.5;
    tput bel
}

smiley() {
    if [ "$?" -eq 0 ];
    then
      echo ":)";
    else
      echo ":(";
    fi
}

# Got from SO -> https://serverfault.com/a/42382
# See `.functions.macos` for MacOS specific (shows notification)
is_host_up() {
	echo "Pinging $1 until host is up..."
	ping_cancelled=false    # Keep track of whether the loop was cancelled, or succeeded
	until ping -c1 "$1" &>/dev/null; do echo "[$(date +'%Y-%m-%d @ %H:%M:%S')] Still waiting for $1..."; done &    # The "&" backgrounds it
	trap "kill $!; ping_cancelled =true" SIGINT
	wait $!          # Wait for the loop to exit, one way or another
	trap - SIGINT    # Remove the trap, now we're done with it
	echo "Done pinging, cancelled=$ping_cancelled"
}

# Got from SO -> https://stackoverflow.com/a/29655125
perf() {
  curl -o /dev/null -s -w "%{time_connect} + %{time_starttransfer} = %{time_total}\n" "$1"
}

# Better `dig` command - My own unique idea...(I'm sure someone else thought of this before)
dig() {
  # function that calls `dig` but will first strip of `http` or `https` from the URL
  # and any trailing slashes, then calling `dig` with the stripped URL
  # Example: dig https://www.google.com/ -> dig www.google.com  
  local args=()
  local domain_found=false

  for arg in "$@"; do
    if [[ "$arg" == -* || "$arg" == +* || "$arg" == @* || "$domain_found" == true ]]; then
      # Flags or already handled domain — pass through
      args+=("$arg")
    else
      # First non-flag argument — sanitize it
      domain="${arg#http://}"
      domain="${domain#https://}"
      domain="${domain%%/*}"
      args+=("$domain")
      domain_found=true
    fi
  done

  # Call the real dig
#  echo "Calling: dig "${args[@]}""
  command dig "${args[@]}"
}

genpasswd() {
   local l=$1
   [ "$l" == "" ] && l=16
   tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

extract() {
  if [[ -f "$1" ]] ; then
      case "$1" in
          *.tar.bz2)   tar xvjf "$1"    ;;
          *.tar.gz)    tar xvzf "$1"    ;;
          *.bz2)       bunzip2 "$1"     ;;
          *.rar)       rar x "$1"       ;;
          *.gz)        gunzip "$1"      ;;
          *.tar)       tar xvf "$1"     ;;
          *.jar)       jar xf "$1"      ;;
          *.tbz2)      tar xvjf "$1"    ;;
          *.tgz)       tar xvzf "$1"    ;;
          *.zip)       unzip "$1"       ;;
          *.Z)         uncompress "$1"  ;;
          *.7z)        7z x "$1"        ;;
          *)           if ! 7z x "$1" ; then echo "[ERROR] Sorry, don't know how to extract '$1'..." ; fi ;;
      esac
  else
      echo "'$1' is not a valid file!"
  fi
}

# Start a local SMTP server for testing in python
smtp-server() {
  echo "SMTP Server created on 'localhost:1025' - [Ctrl] + [C] to exit."
  python -m smtpd -n -c DebuggingServer localhost:1025
}

# `lq` is an alias to convert LDIF results to a JSON blob, it's real hacky: (Thank you Luke Y! ;) )
lq () {
    awk '!/^#/' | jq -Rs '[split("\n\n")[] | select(length >0) | [split("\n")[] | {attribute: split(": ")[0], value: (split(": ")[1:] | join(": "))}] | [group_by(.attribute)[] | { key: .[0].attribute, value: [.[].value]}] | from_entries]'
}

# Convert an image into a base64 string for textual embedding in a webpage
#   - Taken from: https://codewithhugo.com/convert-image-data-url/
function img-data() {
  TYPE=$(file --mime-type -b $1)
  ENC=$(base64 $1)
  echo "data:$TYPE;base64,$ENC"
}

function mkvenv() {
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: mkvenv [python_version]"
    echo
    echo "Creates a Python virtual environment and installs dependencies."
    echo
    echo "Arguments:"
    echo "  python_version  (optional) The version of Python to use (e.g., 3.11)."
    echo "                  If not provided, defaults to the system's python3."
    echo
    echo "Example:"
    echo "  mkvenv 3.11"
    return
  fi

  PYTHON_VERSION=${1:-3}

  # Create the virtual environment
  python"$PYTHON_VERSION" -m venv venv
  ln -s venv/bin/activate activate
  source activate
  pip install --upgrade pip
  pip install setuptools
  pip install pip-chill
  if [[ -f requirements.txt ]]; then
    pip install -r requirements.txt
  fi
  echo
  echo "Installed Dependencies"
  echo "======================"
  pip-chill
  echo
  echo "pip & python Paths"
  echo "=================="
  which pip python python3
}
